// Mostly generated by https://www.npmjs.com/package/typescript-closure-tools

declare module puppet.logging {

    class DebugRecorder_ extends DebugRecorder___Class { }
    /** Fake class which should be extended to avoid inheriting static properties */
    class DebugRecorder___Class  {

        /**
         * DebugRecorder class. Contains debug message lists for display when
         * run-commands or assertions return false, and has functions to clear and echo
         * these.
         * To add a debug message from a command, use puppet.debug(message).
         *
         * @private
         * @constructor
         */
        constructor();

        /**
         * Logs debug messages if:
         * A command has returned false for a period of time and messages are new
         * or have changed.
         * A command has returned false for this period of time and then becomes true.
         *
         * @param {boolean} commandIsTrue The command returned true.
         */
        maybeEchoMessages(commandIsTrue: boolean): void;

        /**
         * Logs debug messages. The messages are logged immediately and then discarded,
         * so they are never shown by maybeEchoMessages.
         */
        echoMessages(): void;

        /**
         * Adds a debug message to be displayed when the run-command returns false.
         *
         * @param {string} msg Message to be added.
         */
        addMessage(msg: string): void;
    }


    /**
     * Native console functions that will be hijacked.
     * @enum {string}
     * @private
     */
    interface ConsoleFunctionName_ {
        LOG: string,
        WARN: string,
        ERROR: string
    }

    /**
     * Registers a log listener to be notified of log'ed strings.
     * When, notified, the listener is given two strings arguments,
     * the first HTML formatted and the second in plain text.
     *
     * @param {function(string, string)} listener The listener.
     */
    function addLogListener(listener: { (_0: string, _1: string): void }): void;

    /**
     * Converts anything to string, outputting functions by names not
     * definitions, and outputting strings with enclosing quotes.
     *
     * @param {*} x Anything.
     * @return {string} String representation.
     */
    function toString(x: any): string;

    /**
     * Proxies the console object passed into it. The original functions
     * consoleObject.log, consoleObject.warn, consoleObject.error are stashed and
     * new functions are assigned to them instead so that they get passed through
     * to puppet.
     *
     * @param {!Console} consoleObject Caller should inject the window.console
     *     object here.
     */
    function hijackConsole(consoleObject: Console): void;

    /**
     * Logs a string by notifying each of the log listeners.
     *
     * @param {*} x Anything, but assumes strings are HTML.
     */
    function log(x: any): void;

    /**
     * Logs a string by notifying error listener.
     *
     * @param {*} x Anything, but assumes strings are HTML.
     */
    function error(x: any): void;

    /**
     * If the value has a boolean evaluation of false, calls puppet.logging.error
     * with the given logging string.
     *
     * @param {*} value Anything.
     * @param {*=} opt_x Anything, but assumes strings are HTML; defaults to value.
     */
    function check(value: any, opt_x?: any): void;

    /**
     * Sets an error listener to be notified when there is an error
     * during assert.
     *
     * @param {function()} listener The listener.
     */
    function setErrorListener(listener: { (): void }): void;

    /**
     * Adds a debug message to be displayed.
     *
     * @param {string} msg Message to be added.
     */
    function debug(msg: string): void;

    /**
     * Log debug messages.
     *
     * @param {boolean} commandIsTrue The command returned true.
     */
    function maybeLogDebugMessages(commandIsTrue: boolean): void;

    /**
     * Gets the elapsed seconds since the loading of the document.
     *
     * @return {string} the elapsed seconds.
     */
    function time(): string;
}

declare module puppet.params {

    /**
     * Declare a boolean parameter and return its value.
     *
     * @param {string} name Name of the parameter.
     * @return {boolean} Whether the parameter is present in the URL.
     */
    function declareBoolean(name: string): boolean;

    /**
     * Declare a number parameter and return its value.
     *
     * @param {string} name Name of the parameter.
     * @param {number} defaultValue Default value of the parameter.
     * @return {number} Number value of the parameter in the URL if present;
     *     the default value if not present.
     */
    function declareNumber(name: string, defaultValue: number): number;

    /**
     * Declare a string parameter and return its value.
     *
     * @param {string} name Name of the parameter.
     * @param {string} defaultValue Default value of the parameter.
     * @return {string} String value of the parameter in the URL if present;
     *     the default value if not present.
     */
    function declareString(name: string, defaultValue: string): string;

    /**
     * Declare a multistring parameter, where comma is the string delimiter,
     * and return its value.
     *
     * @param {string} name Name of the parameter.
     * @param {!Array.<string>} defaultValue Default value of the parameter.
     * @return {!Array.<string>} Array value of the parameter in the URL if present;
     *     the default value if not present.
     */
    function declareMultistring(name: string, defaultValue: string[]): string[];

    /**
     * Declare a RegExp parameter and return its value.
     *
     * @param {!string} name Name of the parameter.
     * @param {string|!RegExp} defaultValue Default value of the parameter.
     * @return {!RegExp} RegExp value of the parameter in the URL if present;
     *     the default value if not present.
     */
    function declareRegExp(name: string, defaultValue: string|RegExp): RegExp;

    /**
     * Returns a map object of all key, value pairs in the test URL.
     *
     * @return {!Object.<string,string>} All key, value pairs in the URL.
     */
    function getAll(): { [key: string]: string };

    /**
     * Returns a map object of all key, value pairs in the test URL that
     * were not explicitly declared.
     *
     * @return {!Object.<string,string>} Undeclared key, value pairs in the URL.
     */
    function getUndeclared(): { [key: string]: string };

    /**
     * Gets the value for the given parameter in the URL, or null if the
     * parameter is not in the URL. If no URL is given,
     * window.location.href is used.
     *
     * @param {string} name Parameter name.
     * @param {string=} opt_url A URL; defaults to window.location.href.
     * @return {?string} The value of the parameter name in the URL.
     */
    function getUrlParam(name: string, opt_url?: string): string;

    /**
     * Returns a URL the same as the given URL, but with the given
     * parameter name set to the given value. If no URL is given,
     * window.location.href is used.
     *
     * @param {string} name Parameter name.
     * @param {string} value Parameter value.
     * @param {string=} opt_url A URL; defaults to window.location.href.
     * @return {string} URL overwritten with the name/value pair.
     */
    function setUrlParam(name: string, value: string, opt_url?: string): string;

    /**
     * Returns a URL the same as the given URL, but with the
     * parameter of the given name removed. If no URL is given,
     * window.location.href is used.
     *
     * @param {string} name Parameter name.
     * @param {string=} opt_url A URL; defaults to window.location.href.
     * @return {string} URL with the parameter removed.
     */
    function removeUrlParam(name: string, opt_url?: string): string;
}

// Typescript definitions for puppet.js

// From bot
// TODO: typescript + selenium?
declare module bot {
    module Keyboard {
        interface key {

        }
    }

    interface Keyboard {

    }

    interface Touchscreen {

    }
}

// Sizzle that gets grafted
declare function $(selector: string): { (): Element[] }

declare module puppet {
    interface Mouse {}
    interface Touchscreen {}

    export module Console {
        interface MenuItem {

        }
    }

    /**
     * Makes a GET/POST request via an XMLHttpRequest.
     *
     * @param {string} url URL to request.
     * @param {string=} opt_type Request type: 'GET' (default) or 'POST'.
     * @param {?string=} opt_body Request body; defaults to null.
     * @param {boolean=} opt_async Whether the request is asynchronous;
     *    defaults to false.
     * @param {Object=} opt_headers Request headers; defaults to null.
     * @return {?string} Response text; null if the HTTP response status
     *     code is not 200.
     */
    function request(url: string, opt_type?: string, opt_body?: string, opt_async?: boolean, opt_headers?: Object): string;

    /**
     * Evaluates the JavaScript synchronously from the specified relative server
     * path. It is resolved relative to the location of this puppet.js file, NOT
     * relative to the file in which it is called and NOT relative to the test
     * itself. If the path has already been included, this is a noop.
     *
     * @param {string} path Relative path to the JavaScript file.
     * @return {boolean} Whether a non-empty JavaScript file was found.
     */
    function include(path: string): boolean;

    /**
     * Returns a relative url to the test file being run. E.g., if the window
     * location is "http://www.google.com/tests/mytest.html?time=100#a", the test
     * url would be "/tests/mytest.html?time=100#a".
     *
     * @return {string} Relative url to the test.
     */
    function testUrl(): string;

    /**
     * Gets the content window being tested.
     *
     * @return {!Window} Content window.
     */
    function window(): Window;

    /**
     * Gets the content document being tested.
     *
     * @return {!Document} Content document.
     */
    function document(): Document;

    /**
     * Gets the content location being tested.
     *
     * @return {!Location} Location.
     */
    function location(): Location;

    /**
     * Add menu items to a project-specific menu.
     *
     * @param {!Array.<!puppet.Console.MenuItem>} items Menu items.
     */
    function addMenuItems(items: puppet.Console.MenuItem[]): void;

    /**
     * Enum for the status of a test.
     * @enum {{message: string, color: string}}
     */
    namespace TestStatus {
        var LOADED: puppet.TestStatusType;
        var PASSED: puppet.TestStatusType;
        var FAILED: puppet.TestStatusType;
    }

    interface TestStatusType {
        message: string;
        color: string;
    }

    /**
     * Returns the status of the Puppet test execution.
     *
     * @return {?puppet.TestStatus} Status of the test execution.
     */
    function getStatus(): puppet.TestStatusType;

    /**
     * Parameters to control the behavior of Puppet.
     *
     * @type {{
     *   close: boolean,
     *   cmds: !Array.<string>,
     *   delay: number,
     *   fullpage: boolean,
     *   hidelog: boolean,
     *   hidemenu: boolean,
     *   lines: !Array.<string>,
     *   step: boolean,
     *   time: number,
     *   timeout: number,
     *   verbose: boolean,
     *   width: string
     * }}
     * @const
     */
    var PARAMS: { close: boolean; cmds: string[]; delay: number; fullpage: boolean; hidelog: boolean; hidemenu: boolean; lines: string[]; step: boolean; time: number; timeout: number; verbose: boolean; width: string };

    /**
     * Gets the command timeout.
     *
     * @return {number} Seconds to wait before command timeout.
     */
    function getCommandTimeoutSecs(): number;

    /**
     * Sets the command timeout.
     *
     * @param {number} timeoutSecs Seconds to wait before command timeout.
     */
    function setCommandTimeoutSecs(timeoutSecs: number): void;

    /**
     * Sets the command delay.
     *
     * @param {number} delayMs Milliseconds to wait before command execution.
     */
    function setDelayMs(delayMs: number): void;

    /**
     * Sets the command retry delay. Defaults to 200 milliseconds in case of a value
     * less than or equal to zero.
     *
     * @param {number} retryMs Milliseconds to wait before retrying a failed
     *     command.
     */
    function setRetryMs(retryMs: number): void;

    /**
     * Returns the {@link bot.Keyboard} used by action commands.
     *
     * @return {!bot.Keyboard} Keyboard used by Puppet.
     */
    function keyboard(): bot.Keyboard;

    /**
     * Returns the {@link puppet.Mouse} used by action commands.
     *
     * @return {!puppet.Mouse} Mouse used by Puppet.
     */
    function mouse(): puppet.Mouse;

    /**
     * Returns the {@link puppet.Touchscreen} used by action commands.
     *
     * @return {!puppet.Touchscreen} Touchscreen used by Puppet.
     */
    function touchscreen(): puppet.Touchscreen;

    /**
     * A helper function for defining a Puppet command. It accepts two arguments:
     * a boolean, indicating whether this is an "action" command that should,
     * therefore check whether the element is in an interactable state; and a
     * continuation function to run if all the command preconditions are satisfied.
     *
     * The returned command function accepts as a first argument a xpath string or
     * an element, and if a string, evaluates it to an element. If it does not
     * resolve, the command function returns false immediately. If the action
     * argument is true, it additionally checks whether the element is in an
     * "interactable" state, meaning it is shown to the user and not disabled.
     * If these checks all pass, it calls the continuation function with the
     * element, a description of the element, followed by whatever additional
     * arguments it was passed, and it coerses return values !== false, to true.
     *
     * @param {boolean} action Whether this is used for an action command.
     * @param {function(!Element, string, ...) : *} fn Continuation function.
     * @return {function((string|!Element), ...) : boolean} Command function.
     */
    function command(action: boolean, fn: {(elem : Element, str: string, ...var_args: any[]) : any}): {(strOrElem : string | Element, ...var_args: any[]) : boolean};

    /**
     * Returns the effective style of the element for the given property.
     * Returns null if the value is never specified.
     *
     * @param {!Element} elem Element.
     * @param {!string} key The style property.
     * @return {?string} Effective style or null if not specified.
     */
    function style(elem: Element, key: string): string;

    /**
     * Returns the value for the attribute with the given name, or null if the
     * element does not have an attribute with that name.
     *
     * @param {!Element} elem Element.
     * @param {string} name Name of the attribute.
     * @return {?string} The attribute value.
     */
    function attribute(elem: Element, name: string): string;

    /**
     * Returns the value for the given property name, undefined if the element does
     * not have a property with that name.
     *
     * @param {!Element} elem Element.
     * @param {string} name Name of the property.
     * @return {*} The property value.
     */
    function property(elem: Element, name: string): any;

    /**
     * Returns the element's visible text as the user would see it in the browser.
     *
     * @param {!Element} elem Element.
     * @return {string} The element's text.
     */
    function text(elem: Element): string;

    /**
     * Matches a string against another string or regular expression.
     *
     * If the pattern is a string, uses '==='; if it is a regular
     * expression, uses RegExp.test().
     *
     * @param {string} str String to be matched.
     * @param {string|!RegExp} pattern Regular expression pattern.
     * @return {boolean} Whether the string matches the pattern.
     */
    function matches(str: string, pattern: string|RegExp): boolean;

    /**
     * Matches a string against a regular expression and, if it matches,
     * returns the substring that matches the first parenthesized
     * expression in the pattern.
     *
     * @param {string} str String to be matched.
     * @param {!RegExp} pattern Regular expression pattern.
     * @return {?string} The matched subtring, or null if no match.
     */
    function match(str: string, pattern: RegExp): string;

    /**
     * By default, the click and drag commands will issue touch actions (tap and
     * swipe, respectively) when the test runs on a touch device. If mouse actions
     * are desired for click and drag, even when on a touch device, call this
     * function with true.
     *
     * @param {boolean} forceMouseActions Whether to always use mouse actions for
     *     click and drag commands.
     */
    function setForceMouseActions(forceMouseActions: boolean): void;

    /**
     * Gets the effective offset from the left of an element.
     *
     * @param {!Element} elem Element.
     * @return {number} offset.
     * @deprecated Use puppet.clientRect instead.
     */
    function left(elem: Element): number;

    /**
     * Gets the effective offset from the top of an element.
     *
     * @param {!Element} elem Element.
     * @return {number} Offset from the top of the element.
     * @deprecated Use puppet.clientRect instead.
     */
    function top(elem: Element): number;

    /**
     * Gets the client rectange of a DOM element relative to the client viewport.
     *
     * @param {!Element} elem Element.
     * @return {{height: number, left: number, top: number, width: number}} The
     *     client rectangle of the element relative to the client viewport.
     */
    function clientRect(elem: Element): { height: number; left: number; top: number; width: number };

    /**
     * Focuses on the given element if it is not already the active element. If
     * a focus change is required, the active element will be blurred before
     * focusing on the given element.
     *
     * @param {!Element} elem The element to focus on.
     */
    function focus(elem: Element): void;

    /**
     * Echos a string to the command log. If the argument is a string, it
     * is expected to be HTML, with proper character escaping and may
     * include links and other HTML text formatting.
     *
     * This function also echos to the Firebug console if it's available,
     * and to the standard output of the Unix terminal for Firefox if the
     * browser.dom.window.dump.enabled is set to true in about:config.
     *
     * @param {*} x Anything, but assumes strings are HTML.
     */
    function echo(x: any): void;

    /**
     * Asserts a value is true. Evaluates !value and throws an exception
     * and stops testing if it is false.
     *
     * @param {*} value Anything.
     * @param {string=} opt_comment Comment to echo if false.
     */
    function assert(value: any, opt_comment?: string): void;

    /**
     * Gets the single element matching an XPath expression.
     *
     * Returns null if no such element matches the expression and throws
     * an exception if multiple elements match it.
     *
     * @param {string|!Element|function(): !Array.<!Element>} pathOrElem XPath
     *     or element or function that returns an array of elements.
     * @return {Element} The element or null if none at that path.
     */
    function elem(pathOrElem: string|Element|{ (): Element[] }): Element;

    /**
     * Gets all elements by an XPath expression.
     *
     * @param {string|!Array.<!Element>|function(): !Array.<!Element>} pathOrElems
     *    XPath or array of elements or function that an array of elements.
     * @return {!Array.<!Element>} Elements at the given path.
     */
    function elems(pathOrElems: string|Element[]|{ (): Element[] }): Element[];

    /**
     * Adds a listener this is called whenever an element is located, excluding
     * cached elements.
     *
     * @param {function((!Element|!Array.<!Element>),
     *     (string|!Element|!Array.<!Element>|function(): !Array.<!Element>))}
     *     listener Listener function.
     */
    function addElemListener(listener: { (_0: Element | Element[], _1: (string|Element|Element[]|{ () : Element[] })) }): void;

    /**
     * Defines recursive objects. For example:
     *   puppet.define({ x: 1 }, function(me) { return { y: me.x + 2 };})
     * gives { x: 1, y: 3 }
     *
     * @param {!Object} x An initial object.
     * @param {...[function(!Object) : !Object]} var_args Variable length
     *   number of functions that take the base object and returns an
     *   extended object.
     * @return {!Object} The recursively defined object.
     */
    function define(x: Object, ...var_args: { (_0: Object): Object }[]): Object;

    /**
     * Resize the content iframe window to a given width.
     *
     * @param {string} width Width of the window (e.g. 800px or 100%).
     * @deprecated Use resize instead.
     */
    function resizeWidth(width: string): void;

    /**
     * Resize the content iframe window to a given height.
     *
     * @param {string} height Height of the window (e.g. 800px or 100%).
     * @deprecated Use resize instead.
     */
    function resizeHeight(height: string): void;

    /**
     * Adds a debug message to be displayed when the run-command returns false.
     *
     * @param {string} msg Message to be added.
     */
    function debug(msg: string): void;

    /**
     * The arguments in the last call of window.open.
     *
     * Puppet cannot control or check elements in new windows opened by
     * the test applications via window.open(). Mock window.open() and
     * save the arguments (URL, window name, and properties) such that the
     * test can load the URL manually.
     *
     * @type {Array}
     */
    var openArgs: any[];

    /**
     * Appends all load parameters specified in the test URL to the given URL.
     * Load parameters are those that are prefixed with "load:".
     *
     * @param {string} url A URL.
     * @return {string} The URL with additional load parameters.
     */
    function appendLoadParams(url: string): string;

    /**
     * Initializes the window object for the new document.
     */
    function initWindow(): void;

    /**
     * Makes an asynchronous call to a Javascript file. The evaluation of
     * that Javascript may complete after this function returns.
     *
     * @param {string} url URL of the Javascript file to call.
     */
    function call(url: string): void;
}

// Puppet globals:

/**
 * Queues a command to be executed.
 *
 * Calling run(command, arg1, arg2, ...) queues the call command(arg1,
 * arg2, ...) to be executed. If the return value of the call ===
 * false, then the command is retried after a wait period. The command
 * is continually retried until the return value !== false. Note that
 * a command that doesn't explicitly return has a return value of
 * undefined, which is !== false and, therefore, will not be retried.
 *
 * This function also inserts pause() based on ?cmds or ?lines.
 *
 * @param {(function(...) : *)=} command Command to be queued.
 * @param {...*} var_args Arguments to the function.
 */
declare function run(command: { (...var_args: any[]): any }, ...var_args: any[]): void;

/**
 * Use this command whenever a new page is to be loaded. If given a
 * URL, it loads the URL and waits until the document is loaded. If
 * given a command, it returns a new command that performs the given
 * command and then waits for a document to be loaded.
 *
 * @param {string|function(...) : *} urlOrCommand URL of the
 *     document to be loaded or a command to performed before the
 *     new document is loaded.
 * @return {undefined|function(...[*]) : *} If given a command, this
 *     is the new command that also waits for the page to load.
 */
declare function load(urlOrCommand : string|{ (...var_args: any[]): any }): { (...var_args: any[]): any };

/**
 * Reloads the current page and waits until the document is fully
 * loaded.
 */
declare function reload(): void;

/**
 * Go back in the browser history. The number of pages to go back can
 * optionally be specified and defaults to 1.
 *
 * @param {number=} opt_numPages Number of pages to go back.
 */
declare function back(opt_numPages?: number): void;

/**
 * Go forward in the browser history. The number of pages to go forward can
 * optionally be specified and defaults to 1.
 *
 * @param {number=} opt_numPages Number of pages to go forward.
 */
declare function forward(opt_numPages?: number): void;

/**
 * Switches the window under test.
 *
 * @param {!Window} win The new window for command execution.
 */
declare function switchto(win: Window) : void;

/**
 * Returns whether the element is present in the DOM.
 *
 * @param {string|!Element} pathOrElem Xpath or the target element.
 * @return {boolean} Whether the element is present in the DOM.
 */
declare function present(pathOrElem: string | Element): boolean;

/**
 * Returns whether the element is shown to the user.
 *
 * @param {string|!Element} pathOrElem XPath or element.
 * @return {boolean} Whether the element is shown.
 */
declare function shown(pathOrElem: string | Element): boolean;

/**
 * Shown above seems to work even if the element is offscreen.
 * This function makes sure the element is visible on screen w/o scrolling (vertically at least)
 * Algorithm borrowed from https://github.com/customd/jquery-visible/blob/master/jquery.visible.js
 * @param {string|!Element} pathOrElem XPath or element.
 * @param {boolean=} opt_partial Whether to check if all of the element is on screen or just part of it.
 * @return {boolean} Whether the element is on screen.
 */
declare function onscreen(pathOrElem: string | Element): boolean;

/**
 * Returns true iff the element has the given opacity.
 *
 * @param {string|!Element} pathOrElem XPath or element.
 * @param {number} value Minimum expected opacity of the element.
 * @param {number=} opt_max Maximum expected opacity of the element.
 *     If not provided, defaults to the minimum value.
 * @return {boolean} Whether the element's opacity is within the given bounds.
 */
declare function opacity(pathOrElem: string|Element, value: number, opt_max?: number): boolean;

/**
 * Returns true iff the element is present and has a style attribute
 * with the given key/value pair.
 *
 * @param {string|!Element} pathOrElem XPath or element.
 * @param {string} key Key of the style.
 * @param {string|!RegExp} value Value of the style.
 * @return {boolean} Whether the element's style has the key/value.
 */
declare function style(pathOrElem: string|Element, key: string, value: string|RegExp): boolean;

/**
 * Returns whether the element is present, has an attribute with the given name,
 * and if opt_value is given, whether it matches the actual attribute value. If
 * the value is a RegExp, tests the actual value matches the RegExp pattern.
 *
 * @param {string|!Element} pathOrElem XPath or element.
 * @param {string} name Name of the attribute.
 * @param {(string|!RegExp)=} opt_value Value of the attribute.
 * @return {boolean} Whether the element has the attribute.
 */
declare function attribute(pathOrElem : string|Element|{(): Element[]}, name: string, opt_value?: string|RegExp): boolean;

/**
 * Returns whether the element is present, has a property with the given name,
 * and if opt_value is given, whether it matches the actual property value. If
 * the value is a RegExp, tests the actual value matches the RegExp pattern.
 *
 * @param {string|!Element} pathOrElem XPath or element.
 * @param {string} name Name of the property.
 * @param {*=} opt_value Value of the property.
 * @return {boolean} Whether the element has the property.
 */
declare function property(pathOrElem: string|Element, name: string, opt_value?: string | RegExp): boolean;

/**
 * Returns true iff the element is present and has the given visible text.
 *
 * @param {string|!Element} pathOrElem XPath or element.
 * @param {string|!RegExp} value Text value.
 * @return {boolean} Whether the element has that text.
 */
declare function text(pathOrElem: string|Element|{(): Element[]}, value: string|RegExp): boolean;

/**
 * Returns whether the given element is selected. Throws an exception
 * if the element is not an option, checkbox, or radio button.
 *
 * @param {string|!Element} pathOrElem XPath or element.
 * @return {boolean} Whether the element is selected.
 */
declare function selected(pathOrElem: string|Element): boolean;

/**
 * Returns true iff the element is shown, and if it is, clears the user input
 * from the element. If the element contains text, clears the text. If it is
 * a selected checkbox, clicks it to deselect it.
 *
 * @param {string|!Element} pathOrElem XPath or element to clear.
 * @return {boolean} Whether the element is shown.
 */
declare function clear(pathOrElem: string|Element): boolean;

/**
 * Types a string, presses a key or key sequence to an element and
 * returns true iff the element is shown.
 *
 * The parameters after the element can be:
 * 1. A string, like:
 *    run(type, textbox, 'abc')
 * 2. A key code to be pressed, like:
 *    run(type, textbox, goog.events.KeyCodes.ENTER)
 * 3. An array of strings or keycodes, like:
 *    run(type, textbox, ['a', goog.events.KeyCodes.ENTER, 'b'])
 * 4. A variable number of any of the above, like:
 *    run(type, textbox, 'a', goog.events.KeyCodes.ENTER, ['b', 'c'])
 *
 * @param {string|!Element} pathOrElem XPath or element.
 * @param {...(string|bot.Keyboard.Key|!Array.<string|bot.Keyboard.Key>)
 *     } var_args The values to type into element.
 * @return {boolean} Whether the element is shown.
 */
declare function type(pathOrElem: string|Element, ...var_args: (string|bot.Keyboard.key|(string|bot.Keyboard.key)[])[]): void;

/**
 * Returns true iff the element is shown, and if it is, moves the mouse to
 * the element, over the optional x and y coordinates relative to the element.
 *
 * @param {string|!Element} pathOrElem XPath or element to move the mouse to.
 * @param {number=} opt_x The x coordinate relative to the element.
 * @param {number=} opt_y The y coordinate relative to the element.
 * @return {boolean} Whether the element is shown.
 */
declare function movemouse(pathOrElem: string|Element, opt_x?: number, opt_y?: number): boolean;

/**
 * Returns true iff the element is shown, and if it is clicks an element at the
 * optional x and y client coordinates, relative to the element. If this click
 * has a target URL, ensure the link is relative so it won't go off-site.
 *
 * @param {string|!Element} pathOrElem XPath or element to click.
 * @param {number=} opt_x The x coordinate relative to the element.
 * @param {number=} opt_y The y coordinate relative to the element.
 * @return {boolean} Whether the element is shown.
 */
declare function click(pathOrElem: string|Element, opt_x?: number, opt_y?: number): boolean;

/**
 * Returns true iff the element is shown, and if it is taps an element at the
 * optional x and y client coordinates, relative to the element. If this tap
 * has a target URL, ensure the link is relative so it won't go off-site.
 *
 * @param {string|!Element} pathOrElem XPath or element to tap.
 * @param {number=} opt_x The x coordinate relative to the element.
 * @param {number=} opt_y The y coordinate relative to the element.
 * @return {boolean} Whether the element is shown.
 */
declare function tap(pathOrElem: string|Element, opt_x?: number, opt_y?: number): boolean;

/**
 * Returns true iff the element is shown, and if it is right-clicks an element
 * at the optional x and y client coordinates, relative to the element.
 *
 * @param {string|!Element} pathOrElem XPath or element to right-click.
 * @param {number=} opt_x The x coordinate relative to the element.
 * @param {number=} opt_y The y coordinate relative to the element.
 * @return {boolean} Whether the element is shown.
 */
declare function rightclick(pathOrElem: string|Element, opt_x?: number, opt_y?: number): boolean;

/**
 * Returns true iff the element is shown, and if it is double-clicks an element
 * at the optional x and y client coordinates, relative to the element.
 *
 * @param {string|!Element} pathOrElem XPath or element to double-click.
 * @param {number=} opt_x The x coordinate relative to the element.
 * @param {number=} opt_y The y coordinate relative to the element.
 * @return {boolean} Whether the element is shown.
 */
declare function doubleclick(pathOrElem: string|Element, opt_x?: number, opt_y?: number): boolean;

/**
 * Returns true iff the element is shown, and if it is, scrolls the mouse wheel
 * by the specified number of ticks on the element at the optional x and y
 * coordinates relative to the element. A positive number of ticks scrolls
 * downward and a negative number scrolls upward.
 *
 * @param {string|!Element} pathOrElem XPath or element to move the mouse to.
 * @param {number} ticks The number of ticks to scroll the mouse wheel.
 * @param {number=} opt_x The x coordinate relative to the element.
 * @param {number=} opt_y The y coordinate relative to the element.
 * @return {boolean} Whether the element is shown.
 */
declare function scrollmouse(pathOrElem: string|Element, ticks: number, opt_x?: number, opt_y?: number): boolean;

/**
 * Returns true if the element is shown, and if it is follow's the link of the
 * given anchor element.
 *
 * Do not use follow() to simulate left-clicking a link: use click()
 * instead. Use follow() only to simulate opening a link in a new
 * window/tab.
 *
 * @param {string|!Element} pathOrElem XPath or element to follow.
 * @return {boolean} Whether the element is shown.
 */
declare function follow(pathOrElem: string|Element): boolean;

/**
 * Returns true iff the element is shown, and if it is, fires a mouse event to
 * the element at the optional x and y coordinates, relative to the element.
 *
 * No action if the element is null (to make it easier to trigger
 * multiple mouse events in sequence).
 *
 * @param {string|!Element} pathOrElem XPath or element.
 * @param {string} type event type.
 * @param {number=} opt_x The x coordinate relative to the element.
 * @param {number=} opt_y The y coordinate relative to the element.
 * @param {number=} opt_button The mouse button based on the DOM Level 2 event
 *     model: 0 = left, 1 = middle, 2 = right.
 * @param {number=} opt_detail The scrollwheel amount.
 * @return {boolean} Whether the element is shown.
 */
declare function mouse(pathOrElem: string|Element, type: string, opt_x?: number, opt_y?: number, opt_button?: number, opt_detail?: number): boolean;

/**
 * Returns true if the element is shown, and if it is, drags the
 * element by (dx, dy).
 *
 * @param {string|!Element} pathOrElem XPath or element.
 * @param {number} dx increment in x coordinate.
 * @param {number} dy increment in y coordinate.
 * @param {number=} opt_x The x coordinate relative to the element.
 * @param {number=} opt_y The y coordinate relative to the element.
 * @param {number=} opt_steps The number of steps that should occur as part of
 *     the drag, default is 2.
 * @return {boolean} Whether the element is shown.
 */
declare function drag(pathOrElem: string|Element, dx: number, dy: number, opt_x?: number, opt_y?: number, opt_steps?: number): boolean;

/**
 * Returns true if the element is shown, and if it is, swipes the element by
 * (dx, dy).
 *
 * @param {string|!Element} pathOrElem XPath or element.
 * @param {number} dx increment in x coordinate.
 * @param {number} dy increment in y coordinate.
 * @param {number=} opt_x The x coordinate relative to the element.
 * @param {number=} opt_y The y coordinate relative to the element.
 * @param {number=} opt_steps The number of steps that should occur as part of
 *     the swipe, default is 2.
 * @return {boolean} Whether the element is shown.
 */
declare function swipe(pathOrElem: string|Element, dx: number, dy: number, opt_x?: number, opt_y?: number, opt_steps?: number): boolean;


/**
 * Returns true if the element is shown, and if it is, inputs a value
 * to the given text or password input element or textarea.
 *
 * @param {string|!Element} pathOrElem XPath or element.
 * @param {string} value Value to be inputted.
 * @return {boolean} Whether the element is shown.
 * @deprecated Use type or clear instead.
 */
declare function input(pathOrElem: string|Element, value: string): boolean;

/**
 * Returns true if the element is shown, and if it is, selects the
 * given option element, checkbox, or radio button.
 *
 * @param {string|!Element} pathOrElem XPath or element.
 * @return {boolean} Whether the element is shown.
 * @deprecated Use click() instead.
 */
declare function select(pathOrElem: string|Element): boolean;

/**
 * Returns true if the element is shown, and if it is, focuses it.
 *
 * @param {string|!Element} pathOrElem XPath or element.
 * @return {boolean} Whether the element is shown.
 */
declare function focus(pathOrElem: string|Element): boolean;

/**
 * Returns true if the element is shown, and if it is, blurs it.
 *
 * @param {string|!Element} pathOrElem XPath or element.
 * @return {boolean} Whether the element is shown.
 */
declare function blur(pathOrElem: string|Element): boolean;

/**
 * Returns a multi-element command that returns true iff the specified
 * number of elements matching an xpath satisfy the given command.
 *
 * The multi-element commands accepts an xpath and a variable number
 * of arguments and returns true if the number of elements that both
 * match the xpath and satisfy the command applied to those
 * arguments is in the given range.
 *
 * If the opt_max is not provided, it defaults to num. If it is
 * provided, but null, there is no maximum number. Examples:
 * - run(count(shown, 3) '//a');
 * waits until exactly 3 'a' elements are shown on the page
 * - run(count(shown, 3, 5), '//a');
 * waits until between 3 and 5 (inclusive) a's are shown on the page
 * - run(count(shown, 0, 3), '//a');
 * waits until 3 or less a's are shown on the page
 * - run(count(shown, 3, null), '//a');
 * waits until 3 or more a's are shown on the page
 *
 * @param {function((string|!Element), ...) : *} command
 *     Single-element command.
 * @param {number} num Minimum number of times the command is expected
 *     to not return false.
 * @param {?number=} opt_max Maximum number of times the command is
 *     expected to not return false. If not provided, defaults to
 *     opt_min. If provided but null, there is no maximum limit.
 * @return {function((string|!Array.<!Element>), ...[*]) : boolean}
 *     Multi-element command.
 */
declare function count(command: { (pathOrElem: string|Element, ...var_args: any[]): any }, num: number, opt_max?: number): { (pathOrElem: string|Element[], ...var_args: any[]): boolean };

/**
 * Returns a multi-element command that is true if all elements that
 * match an xpath satisfy the given command.
 *
 * The multi-element command accepts an xpath and a variable number
 * of arguments and returns true if all elements that match the xpath
 * satisfy the command applied to those arguments.
 *
 * Example:
 * - run(all(text), '//a', 'hello');
 * waits until all 'a' elements have text equal to 'hello'
 *
 * @param {function((string|!Element), ...) : *} command
 *     Single-element command.
 * @return {function((string|!Array.<!Element>), ...[*]) : boolean}
 *     Multi-element command.
 */
declare function all(command: { (pathOrElem: string|Element, ...var_args: any[]): any }): { (pathOrElem: string|Element[], ...var_args: any[]): boolean };

/**
 * Returns a multi-element command that is true if there exists an
 * element that matches an xpath that satisfied the given command.
 *
 * The multi-element command accepts an xpath and a variable number
 * of arguments and returns true if an element that matches the xpath
 * satisfies the command applied to those arguments.
 *
 * Example:
 * - run(some(text), '//a', 'hello');
 * waits until some 'a' element has text equal to 'hello'
 *
 * @param {function((string|!Element), ...) : *} command
 *     Single-element command.
 * @return {function((string|!Array.<!Element>), ...[*]) : boolean}
 *     Multi-element command.
 */
declare function some(command: { (pathOrElem: string|Element, ...var_args: any[]): any }): { (pathOrElem: string|Element[], ...var_args: any[]): boolean };

/**
 * Returns a multi-element command that is true if none of the
 * elements that match an xpath satisfy the given predicate.
 *
 * The multi-element command accepts an xpath and a variable number
 * of arguments and returns true if none of the elements that match
 * the xpath satisfy the predicate applied to those arguments.
 *
 * Example:
 * - run(none(text), '//a', 'hello');
 * waits until none of the 'a' elements has text equal to 'hello'
 *
 * @param {function((string|!Element), ...) : *} command
 *     Single-element command.
 * @return {function((string|!Array.<!Element>), ...[*]) : boolean}
 *     Multi-element command.
 */
declare function none(command: { (pathOrElem: string|Element, ...var_args: any[]): any }):  {(pathOrElem: string|Element[], ...var_args: any[]): boolean };

/**
 * Negates the given command.
 *
 * @param {function(...) : *} command Command.
 * @return {function(...[*]) : boolean} Negated command.
 */
declare function not(command: { (...var_args: any[]): any }): { (...var_args: any[]): boolean };

/**
 * Stops the test execution, skipping the rest of the commands.
 *
 * Useful for disabling parts of tests that require certain browsers
 * or operating systems.
 */
declare function stop(): void;

/**
 * Sleeps the test execution for the specified number of seconds.
 *
 * Please avoid using this command if at all possible. It should be
 * used only as a last resort, when waiting for any other changes on
 * the page does not suffice. It is better to add hooks into the page
 * being tested that a test can wait for than to use sleep commands.
 *
 * This command has no effect if the execution is paused.
 *
 * @param {number} sec Number of seconds to sleep.
 */
declare function sleep(sec: number): void;

/**
 * Responds to prompt/confirm/alert dialog boxes. Given a command, returns a new
 * command that performs the new command and waits for a dialog box to appear.
 * When the dialog appears, responds to it with the given response value.
 *
 * <p>A 'prompt' dialog must be given a response of type string, a 'confirm'
 * dialog must be given a response of type boolean, and for an 'alert' dialog,
 * a response type must not be provided.
 *
 * <p>Note that the dialog() function will not work when the page under test
 * aliases and calls its window's alert, confirm, or prompt functions. Example
 * code in a page under test in which the dialog() function will not work:
 * <pre>
 *   var x = window.alert;
 *   x('Hello, world!');
 * </pre>
 * If Puppet's setup phase has not stubbed out the function prior to the alias
 * assignment, then the invocation of x will cause a dialog to appear, and the
 * test will hang and fail when it eventually reaches the whole test timeout.
 * If Puppet's setup phase has stubbed out the function, this dialog() command
 * will nevertheless be unable to set an expectation that an alert will appear,
 * and the invocation of x will fail immediately due to an "unexpected" dialog.
 * If x is accessible from the page's window object, both problems can be
 * avoided if the test stubs out x itself before the page invokes it.
 *
 * @param {function(...):*} command Command expected to trigger the dialog box.
 * @param {(string|boolean)=} opt_response Response to the dialog box.
 * @param {(string|!RegExp)=} opt_message Value to match against dialog message.
 * @return {function(...):*} Command that also expects a dialog box.
 */
declare function dialog(command: { (...var_args: any[]): any }, opt_response?: string|boolean, opt_message?: string|RegExp): { (...var_args: any[]): any };

/**
 * Asserts a value or return value of predicate.
 * Throws an exception and stops testing if it is false.
 *
 * @param {*} value Value or function to evaluate.
 * @param {string=} opt_comment Comment to echo if false.
 */
declare function assert(value: any, opt_comment?: string): void;

/**
 * Asserts that the arguments are equal (===).
 *
 * @param {*} x Any object.
 * @param {*} y Any object.
 * @param {string=} opt_comment Comment on the equality.
 */
declare function assertEq(x: any, y: any, opt_comment?: string): void;

/**
 * Asserts that the arguments are not equal (!==).
 *
 * @param {*} x Any object.
 * @param {*} y Any object.
 * @param {string=} opt_comment Comment on the inequality.
 */
declare function assertNotEq(x: any, y: any, opt_comment?: string): void;

/**
 * Resize the content iframe window to a given width and/or height.
 * Usage:
 *   resize({x: 15}); // Resize to 15 pixels on the x-axis
 *   resize({y: 25}); // Resize to 25 pixels on the y-axis
 *   resize({x: 10, y: 20}); // Resize to 10 x 15 pixels on x and y axis
 *                           // respectively.
 *
 * @param {{x: number, y: number}} dimensions The new window dimensions. The
 *    valid keys for this object are 'x' and 'y'.
 */
declare function resize(dimensions: {x: number, y: number}): void;

/**
 * Scroll the content iframe window to a given width/height or to an element.
 * Usage:
 *   scroll({x: 15}); // Scroll to 15 pixels on the x-axis
 *   scroll({y: 25}); // Scroll to 25 pixels on the y-axis
 *   scroll({x: 10, y: 20}); // Scroll to 10 x 15 pixels on x and y axis
 *                           // respectively.
 *   scroll(puppet.elem(id('a'))); // Scroll to the element with id 'a'.
 *
 * @param {{x: number, y:number}|string|!Element|function(): !Array.<!Element>} positionOrPathOrElemOrElemFunction An XPath
 *     or element to be scrolled into view or the dimensions that indicate the
 *     new scroll position (valid keys for this object are 'x' and 'y').
 */
declare function scroll(positionOrPathOrElemOrElemFunction: {x: number, y:number}|string|Element|{ (): Element[] }): void;

/**
 * Pinches the target by the given distance on multitouch browsers. A positive
 * distance makes the fingers move inwards towards each other and a negative
 * distance makes them move outward away from each other. The optional
 * coordinate is the point the fingers move towards, and if not provided,
 * defaults to the center of the element.
 *
 * @param {string|!Element} pathOrElem XPath predicate of the target element.
 * @param {number} distance Distance to pinch the element.
 * @param {number=} opt_x The x coordinate relative to the element.
 * @param {number=} opt_y The y coordinate relative to the element.
 * @return {boolean} Whether the pinched element is shown.
 */
declare function pinch(pathOrElem: string|Element, distance: number, opt_x?: number, opt_y?: number): boolean;

/**
 * Rotates the target by the given angle for multitouch browsers. A positive
 * angle indicates a clockwise rotation and a positive value indicates a
 * counter-clockwise rotation. The optional coordinate is the point the fingers
 * rotate around.
 *
 * @param {string|!Element} pathOrElem XPath predicate of the target element.
 * @param {number} degrees The degrees of rotation.
 * @param {number=} opt_x The x coordinate relative to the element.
 * @param {number=} opt_y The y coordinate relative to the element.
 * @return {boolean} Whether the rotated element is shown.
 */
declare function rotate(pathOrElem: string|Element, degrees: number, opt_x?: number, opt_y?: number): boolean;

/**
 * Changes the screen orientation. The mode argument must be one of 'portrait',
 * 'landscape', 'portrait-secondary', or 'landscape-secondary'. Throws an
 * exception on non-mobile browsers because their orientation cannot change.
 *
 * @param {string} mode The orientation mode.
 */
declare function orient(mode: string): void;


declare module puppet {

    class Touchscreen extends Touchscreen__Class { }
    /** Fake class which should be extended to avoid inheriting static properties */
    class Touchscreen__Class  {

        /**
         * A class that wraps bot.Touchscreen so that Puppet's API can avoid exposing
         * browser automation atoms internals.
         *
         * @constructor
         */
        constructor();

        /**
         * @return {bot.Touchscreen} The wrapped touchscreen.
         */
        getBotTouchscreen(): bot.Touchscreen;

        /**
         * Press the touch screen.
         *
         * @param {boolean=} opt_press2 Whether or not press the second finger during
         *     the press.  If not defined or false, only the primary finger will be
         *     pressed.
         */
        press(opt_press2?: boolean): void;

        /**
         * Release the touch screen.
         */
        release(): void;

        /**
         * Moves finger along the touchscreen.
         *
         * @param {!Element} element Element that is being pressed.
         * @param {number} x1 The x coordinate for the first press.
         * @param {number} y1 The y coordinate for the first press.
         * @param {number=} opt_x2 The x coordinate for the second press, if any.
         * @param {number=} opt_y2 The y coordinate for the second press, if any.
         */
        move(element: Element, x1: number, y1: number, opt_x2?: number, opt_y2?: number): void;

        /**
         * Returns whether the touchscreen is currently pressed.
         *
         * @return {boolean} Whether the touchscreen is pressed.
         */
        isPressed(): boolean;
    }

}


declare module puppet.userAgent {

    /**
     * @type {{
     *   useragent: string
     * }}
     * @const
     */
    var PARAMS: { useragent: string };

    /**
     * If running Firefox with specified versions.
     *
     * @param {(string|number)=} opt_min Min version.
     * @param {(string|number|null)=} opt_max Max version.
     * @return {boolean} True if userAgent matches Firefox and matches the
     *   optional version parameters. False otherwise.
     */
    function isFirefox(opt_min?: string|number, opt_max?: string|number|any /*null*/): boolean;

    /**
     * If running IE with specified versions.
     * IE refers to both the product and rendering engine.
     *
     * @param {(string|number)=} opt_min Min version.
     * @param {(string|number|null)=} opt_max Max version.
     * @return {boolean} True if userAgent matches IE and matches the
     *   optional version parameters. False otherwise.
     */
    function isIE(opt_min?: string|number, opt_max?: string|number|any /*null*/): boolean;

    /**
     * If running Chrome with specified versions.
     *
     * @param {(string|number)=} opt_min Min version.
     * @param {(string|number|null)=} opt_max Max version.
     * @return {boolean} True if userAgent matches Chrome and matches the
     *   optional version parameters. False otherwise.
     */
    function isChrome(opt_min?: string|number, opt_max?: string|number|any /*null*/): boolean;

    /**
     * If running Safari with specified versions.
     *
     * @param {(string|number)=} opt_min Min version.
     * @param {(string|number|null)=} opt_max Max version.
     * @return {boolean} True if userAgent matches Safari and matches the
     *   optional version parameters. False otherwise.
     */
    function isSafari(opt_min?: string|number, opt_max?: string|number|any /*null*/): boolean;

    /**
     * If running Opera with specified versions.
     * Opera refers to both the product and rendering engine.
     *
     * @param {(string|number)=} opt_min Min version.
     * @param {(string|number|null)=} opt_max Max version.
     * @return {boolean} True if userAgent matches Opera and matches the
     *   optional version parameters. False otherwise.
     */
    function isOpera(opt_min?: string|number, opt_max?: string|number|any /*null*/): boolean;

    /**
     * If running iPad with specified versions.
     *
     * @param {(string|number)=} opt_min Min version.
     * @param {(string|number|null)=} opt_max Max version.
     * @return {boolean} True if userAgent matches iPad and matches the
     *   optional version parameters. False otherwise.
     */
    function isIPad(opt_min?: string|number, opt_max?: string|number|any /*null*/): boolean;

    /**
     * If running iPhone with specified versions.
     *
     * @param {(string|number)=} opt_min Min version.
     * @param {(string|number|null)=} opt_max Max version.
     * @return {boolean} True if userAgent matches iPhone and matches the
     *   optional version parameters. False otherwise.
     */
    function isIPhone(opt_min?: string|number, opt_max?: string|number|any /*null*/): boolean;

    /**
     * If running Android with specified versions.
     *
     * @param {(string|number)=} opt_min Min version.
     * @param {(string|number|null)=} opt_max Max version.
     * @return {boolean} True if userAgent matches Android and matches the
     *   optional version parameters. False otherwise.
     */
    function isAndroid(opt_min?: string|number, opt_max?: string|number|any /*null*/): boolean;

    /**
     * If running Android Mobile with specified versions.
     *
     * @param {(string|number)=} opt_min Min version.
     * @param {(string|number|null)=} opt_max Max version.
     * @return {boolean} True if userAgent matches Android Mobile and matches the
     *   optional version parameters. False otherwise.
     */
    function isAndroidMobile(opt_min?: string|number, opt_max?: string|number|any /*null*/): boolean;

    /**
     * If running Android on Tablet with specified versions.
     *
     * @param {(string|number)=} opt_min Min version.
     * @param {(string|number|null)=} opt_max Max version.
     * @return {boolean} True if userAgent matches Android Tablet and matches the
     *   optional version parameters. False otherwise.
     */
    function isAndroidTablet(opt_min?: string|number, opt_max?: string|number|any /*null*/): boolean;

    /**
     * If running Camino with specified versions.
     *
     * @param {(string|number)=} opt_min Min version.
     * @param {(string|number|null)=} opt_max Max version.
     * @return {boolean} True if userAgent matches Camino and matches the
     *   optional version parameters. False otherwise.
     */
    function isCamino(opt_min?: string|number, opt_max?: string|number|any /*null*/): boolean;

    /**
     * If running on a mobile browser.
     *
     * @return {boolean} True if userAgent matches a mobile browser.
     */
    function isMobile(): boolean;

    /**
     * If running on a multitouch mobile browser.
     *
     * @return {boolean} True if userAgent matches a multi touch mobile browser.
     */
    function isMultiTouch(): boolean;

    /**
     * If running WebKit.
     *
     * @param {(string|number)=} opt_min Min version.
     * @param {(string|number|null)=} opt_max Max version.
     * @return {boolean} True if rendering engine matches WebKit and matches the
     *   optional version parameters. False otherwise.
     */
    function isWebKit(opt_min?: string|number, opt_max?: string|number|any /*null*/): boolean;

    /**
     * If running Mobile WebKit.
     *
     * @param {(string|number)=} opt_min Min version.
     * @param {(string|number|null)=} opt_max Max version.
     * @return {boolean} True if rendering engine matches Mobile WebKit and
     *   matches the optional version parameters. False otherwise.
     */
    function isMobileWebKit(opt_min?: string|number, opt_max?: string|number|any /*null*/): boolean;

    /**
     * If running Gecko.
     *
     * @param {(string|number)=} opt_min Min version.
     * @param {(string|number|null)=} opt_max Max version.
     * @return {boolean} True if rendering engine matches Gecko and matches the
     *   optional version parameters. False otherwise.
     */
    function isGecko(opt_min?: string|number, opt_max?: string|number|any /*null*/): boolean;

    /**
     * If running Windows.
     * Only Windows and Mac support versions.
     *
     * @param {(string|number)=} opt_min Min version.
     * @param {(string|number|null)=} opt_max Max version.
     * @return {boolean} True if platform matches Windows and matches the
     *   optional version parameters. False otherwise.
     */
    function isWindows(opt_min?: string|number, opt_max?: string|number|any /*null*/): boolean;

    /**
     * If running Mac.
     * Only Windows and Mac support versions.
     *
     * @param {(string|number)=} opt_min Min version.
     * @param {(string|number|null)=} opt_max Max version.
     * @return {boolean} True if platform matches Mac and matches the
     *   optional version parameters. False otherwise.
     */
    function isMac(opt_min?: string|number, opt_max?: string|number|any /*null*/): boolean;

    /**
     * If running Linux.
     *
     * @return {boolean} True if platform is Linux.
     */
    function isLinux(): boolean;

    /**
     * If running X11.
     *
     * @return {boolean} True if platform is X11.
     */
    function isX11(): boolean;

    /**
     * If running Blackberry.
     *
     * @return {boolean} True if platform is Blackberry.
     */
    function isBlackberry(): boolean;

    /**
     * If running Blackberry Playbook.
     *
     * @return {boolean} True if platform is Playbook.
     */
    function isPlaybook(): boolean;

    /**
     * If running Dolfin.
     *
     * @return {boolean} True if platform is Dolfin.
     */
    function isDolfin(): boolean;

    /**
     * If running Internet Explorer on a device with a touchscreen.
     *
     * @return {boolean} True if IE with touchscreen.
     */
    function isIETouch(): boolean;

    /**
     * If running Internet Explorer on a device using WebView.
     *
     * @return {boolean} True if IE with WebView.
     */
    function isIEWebView(): boolean;

    /**
     * If running UIWebView in IOS GSA.
     *
     * @return {boolean} True if UIWebView.
     */
    function isUIWebView(): boolean;

    /**
     * Forces reinitialization of goog.userAgent.
     * Modeled after javascript/closure/useragent/product_test.html.
     * Suppress the visibility check, because this needs to access
     * private members of goog.userAgent.
     *
     * @suppress {visibility}
     * @param {string} ua String to simulate.
     */
    function init(ua: string): void;
}


import AttributeFunction = puppet.xpath.AttributeFunction;
declare module puppet.xpath {

    /**
     * Resolves an XPath to a set of DOM nodes.
     *
     * This function handles xpath expressions across frames and iframes by
     * requiring explicit '/content:' annotations and evaluating trailing paths in
     * the (i)frame's document. For example, 'foo/content:/bar' will get the
     * (i)frame element 'foo', then get the element 'bar' inside the document of
     * 'foo'. Use a colon to separate for cases such as 'foo/content:id("bar")'.
     *
     * @param {string} path XPath.
     * @param {!Window} win Document window.
     * @return {!XPathResult} Node set iterator.
     */
    function resolveXPath(path: string, win: Window): XPathResult;

    /**
     * Needed for the xpaths generator below.
     * @typedef {
     *     function(?string=, string=) : string | {
     *       i: (function(?string=, string=) : string),
     *       c: (function(?string=, string=) : string),
     *       ic: (function(?string=, string=) : string),
     *       n: (function(?string=, string=) : string),
     *       nc: (function(?string=, string=) : string),
     *       ni: (function(?string=, string=) : string),
     *       nic: (function(?string=, string=) : string)
     *     }}
     */
    type AttributeFunction = { (_0: string, _1: string): string }|{ i: { (_0: string, _1: string): string }; c: { (_0: string, _1: string): string }; ic: { (_0: string, _1: string): string }; n: { (_0: string, _1: string): string }; nc: { (_0: string, _1: string): string }; ni: { (_0: string, _1: string): string }; nic: { (_0: string, _1: string): string } };

    /**
     * Returns an function that: given a value and an optional context
     * returns an xpath prefixed by that context that matches an element
     * where the given key equals that value. If no context is provided to
     * the function, the default context '//*' (any element) is used.
     *
     * @param {string} key Attribute key.
     * @return {puppet.xpath.AttributeFunction} Function to generate
     *     xpaths for a matching attribute value.
     */
    function makeAttributeFunction(key: string): puppet.xpath.AttributeFunction;

    /**
     * Make a quoted XPath value.
     *
     * E.g.:
     *   foo       becomes  "foo"
     *   foo'bar   becomes  "foo'bar"
     *   foo"bar   becomes  'foo"bar'
     *   foo"bar'  becomes  concat("foo", '"', "bar'")
     *
     * @param {string} str Input.
     * @return {string} Quoted value.
     */
    function quote(str: string): string;

    /**
     * Generates an Xpath expression translating a string to lower-case.
     *
     * @param {string} str A string.
     * @return {string} An Xpath expression of the string in lower-case.
     */
    function lowerCase(str: string): string;
}

/**
 * Optimized XPath predicate for the 'id' attribute for unique
 * identifiers.
 *
 * 'id' should uniquely identify an element, hence the usual prefix
 * path such as //* is not a parameter. It returns expressions of the
 * form 'id("foo")' For performance, do not use expression such as
 * '//*[@id = "foo"]' unless the identifier is not unique, in which
 * case the function idx() below can be used.
 *
 * @param {string} value Id value.
 * @return {string} XPath that resolves to the element with the id.
 */
declare function id(value: string): string;

/**
 * Returns an xpath that resolves to the element at the given zero-based index
 * in the list of elements to which the given xpath resolves.
 *
 * @param {string} path XPath.
 * @param {number} index Zero-based index where negative indices are treated
 *     like python negative indices to indicate relative position from the end
 *     of the array where -1 indicates the last element.
 * @return {string} XPath that resolves to the element at the index.
 */
declare function at(path: string, index: number) : string;

/**
 * Generates XPaths to match elements with a given non-unique 'id'
 * attribute.
 *
 * Useful for combining XPath expressions such as id('foo') +
 * idx('bar') = id("foo")//*[@id = "bar"], and for xpaths such
 * as //*[@id = "bar"][2] for selecting the second match.
 *
 * If the id is expected to be unique, always use id() instead.
 *
 * @type {puppet.xpath.AttributeFunction}
 * @see id
 */
declare var xid: AttributeFunction;


/**
 * Generates XPaths to match elements with a given 'class' attribute.
 *
 * @type {puppet.xpath.AttributeFunction}
 */
declare var xclass: AttributeFunction;


/**
 * Generates XPaths to match elements with a given 'name' attribute.
 *
 * Note that 'window.name' is predefined. In WebKit, window.name is
 * special and cannot even be reassigned.
 *
 * @type {puppet.xpath.AttributeFunction}
 */
declare var xname: AttributeFunction;


/**
 * Generates XPaths to match elements with a given 'title' attribute.
 *
 * @type {puppet.xpath.AttributeFunction}
 * @see puppet.pred
 */
declare var xtitle: AttributeFunction;


/**
 * Generates XPaths to match elements with a given 'style' attribute.
 *
 * @type {puppet.xpath.AttributeFunction}
 */
declare var xstyle: AttributeFunction;


/**
 * Generates XPaths to match elements with a given 'href' attribute.
 *
 * @type {puppet.xpath.AttributeFunction}
 */
declare var xhref: AttributeFunction;


/**
 * Generates XPaths to match elements with a given 'type' attribute.
 *
 * @type {puppet.xpath.AttributeFunction}
 */
declare var xtype: AttributeFunction;


/**
 * Generates XPaths to match elements with a given 'src' attribute.
 *
 * @type {puppet.xpath.AttributeFunction}
 */
declare var xvalue: AttributeFunction;


/**
 * Generates XPaths to match elements with a given 'src' attribute.
 *
 * @type {puppet.xpath.AttributeFunction}
 */
declare var xsrc: AttributeFunction;


/**
 * Generates XPaths to match elements with a given 'text()' subnode.
 *
 * @type {puppet.xpath.AttributeFunction}
 * @see puppet.pred
 */
declare var xtext: AttributeFunction;
